package model.packets;

import model.Packet;
import model.Port;
import model.System;
import model.Line;

import java.awt.*;
import java.util.ArrayList;
import java.util.List;

import static model.Type.OTHERS;

/**
 * Camouflage “secret-2” packet generated by VPN systems.
 * It continually keeps a clearance of {@code SAFE_GAP} pixels
 * from the closest packet on the same wire by moving forward,
 * backward, or hovering in place.
 *
 * ── Helper methods required on {@link Line} ───────────────────────────
 *  • Packet closestAhead(Packet me, float sInSeg, int segIdx)
 *  • Packet closestBehind(Packet me, float sInSeg, int segIdx)
 *  • float  distanceAlong(Packet from, Packet to)
 *    (positive arc-length measured along the line)
 * These can be simple linear scans because each line carries only a
 * handful of packets.
 * ──────────────────────────────────────────────────────────────────────
 */
public final class SecretPacket2<P extends Packet & MessengerTag> extends Packet {

    private static final float BASE_SPEED = 2.0f;   // ≈ 120 px / s
    private static final float SAFE_GAP   = 25f;    // px of clearance

    /* ------------ wrapper bookkeeping ------------ */
    private final ProtectedPacket<P> inner;
    private int systemId;

    /* ------------ per-wire state ------------ */
    private List<Point> path;     // poly-line from Line
    private List<Float> segLen;   // segment lengths
    private int   segIdx  = 0;
    private float sInSeg  = 0f;
    private int   dir     = +1;   // +1 fwd, −1 back, 0 idle

    /* =================  C T O R  ================= */
    public SecretPacket2(ProtectedPacket<P> inner) {
        this.inner = inner;
        this.type  = OTHERS;
        this.size  = 6;
        this.speed = BASE_SPEED;
        this.acceleration = 0f;
    }

    /* =================  A P I  =================== */
    public ProtectedPacket<P> unwrap() { return inner; }
    public void              wrongPort(Port p) { /* inert */ }
    public void              setSystemId(int id) { systemId = id; }
    public int               getSystemId()       { return systemId; }

    /* ================= movement ================== */
    @Override
    public void advance(float dt) {
        if (line == null) return;         // not travelling

        /* 0 ▸ cache geometry once */
        if (path == null) initPathTables();

        /* 1 ▸ look for neighbours */
        Packet ahead  = line.closestAhead (this, sInSeg, segIdx);
        Packet behind = line.closestBehind(this, sInSeg, segIdx);

        boolean tooCloseFwd  = ahead  != null &&
                line.distanceAlong(this, ahead ) < SAFE_GAP;
        boolean tooCloseBack = behind != null &&
                line.distanceAlong(behind, this) < SAFE_GAP;

        if (tooCloseFwd && !tooCloseBack)      dir = -1;  // retreat
        else if (tooCloseBack && !tooCloseFwd) dir = +1;  // advance
        else                                   dir = 0;   // hover

        /* 2 ▸ integrate arc-length */
        float remaining = dir * BASE_SPEED * dt;

        while (remaining != 0f && segIdx >= 0 && segIdx < segLen.size()) {

            if (remaining > 0f) {                        // → forward
                float segRemain = segLen.get(segIdx) - sInSeg;
                if (remaining < segRemain) {
                    sInSeg += remaining;
                    remaining = 0f;
                } else {
                    remaining -= segRemain;
                    segIdx++;  sInSeg = 0f;
                }
            } else {                                     // ← backward
                float stepBack = Math.min(-remaining, sInSeg);
                sInSeg -= stepBack;
                remaining += stepBack;
                if (sInSeg == 0f && segIdx > 0) {
                    segIdx--;
                    sInSeg = segLen.get(segIdx);
                }
            }
            updatePoint();
        }

        /* 3 ▸ attempt arrival at either end (only if safe) */
        if (segIdx >= segLen.size()) {                   // destination end
            if (!tooCloseBack) {
                line.getEnd().getParentSystem().receivePacket(this);
            }
        }
        else if (segIdx < 0) {                         // origin end
            if (!tooCloseFwd) {
                line.getStart().getParentSystem().receivePacket(this);
            }
        }
    }

    /* ---------- helpers ---------- */
    private void initPathTables() {
        path   = line.getPath(6);                 // same smoothness everywhere
        segLen = new ArrayList<>(path.size() - 1);
        for (int i = 0; i < path.size() - 1; i++)
            segLen.add((float) path.get(i).distance(path.get(i + 1)));

        segIdx = 0; sInSeg = 0f;
        point  = path.get(0);
        isMoving = true;
    }

    private void updatePoint() {
        if (segIdx < 0 || segIdx >= segLen.size()) return;
        point = lerp(path.get(segIdx), path.get(segIdx + 1),
                sInSeg / segLen.get(segIdx));
    }

    @Override protected void resetPath() {
        path   = null;
        segLen = null;
        segIdx = 0;
        sInSeg = 0f;
    }
}
