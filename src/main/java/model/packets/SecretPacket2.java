package model.packets;

import model.*;
import model.System;

import java.awt.*;
import java.util.ArrayList;
import java.util.List;

import static model.Type.OTHERS;

/**
 * Camouflage “secret-2” packet generated by VPN systems.
 * It continually keeps a clearance of {@code SAFE_GAP} pixels
 * from the closest packet on the same wire by moving forward,
 * backward, or hovering in place.
 *
 * ── Helper methods required on {@link Line} ───────────────────────────
 *  • Packet closestAhead(Packet me, float sInSeg, int segIdx)
 *  • Packet closestBehind(Packet me, float sInSeg, int segIdx)
 *  • float  distanceAlong(Packet from, Packet to)
 *    (positive arc-length measured along the line)
 * These can be simple linear scans because each line carries only a
 * handful of packets.
 * ──────────────────────────────────────────────────────────────────────
 */
public final class SecretPacket2<P extends Packet & MessengerTag> extends Packet {

    private static final float BASE_SPEED = 2.0f;   // ≈ 120 px / s
    private static final float SAFE_GAP   = 25f;    // px of clearance

    /* ------------ wrapper bookkeeping ------------ */
    private final ProtectedPacket<P> inner;
    private int systemId;

    /* ------------ per-wire state ------------ */
    private List<Point> path;     // poly-line from Line
    private List<Float> segLen;   // segment lengths
    private int   segIdx  = 0;
    private float sInSeg  = 0f;
    private int   dir     = +1;   // +1 fwd, −1 back, 0 idle

    /* =================  C T O R  ================= */
    public SecretPacket2(ProtectedPacket<P> inner) {
        this.inner = inner;
        this.type  = OTHERS;
        this.size  = 6;
        this.speed = BASE_SPEED;
        this.acceleration = 0f;
    }

    /* =================  A P I  =================== */
    public ProtectedPacket<P> unwrap() { return inner; }
    public void              wrongPort(Port p) { /* inert */ }
    public void              setSystemId(int id) { systemId = id; }
    public int               getSystemId()       { return systemId; }

    /* ================= movement ================== */
    /* ================= movement ================== */
    @Override
    public void advance(float dt) {
        /* ── 0 ▸ bail if we’re not attached to a wire ─────────────────── */
        if (line == null) return;

        /* ── 1 ▸ one-time geometry cache ──────────────────────────────── */
        if (path == null) initPathTables();

    /* ── 2 ▸ “protection zone” check --------------------------------
       We look at every other packet on the *same* line.  If any are
       inside a circle of radius SAFE_GAP around our current point,
       we step *away* from their barycentre; otherwise we cruise fwd. */
        /* ── 2 ▸ protection-zone scan (all packets, not only same wire) ───── */
        double avgX = 0, avgY = 0;
        int    hits = 0;

        /* any packet that currently has a visible point counts */
        SystemManager mgr =
                line.getStart().getParentSystem().getSystemManager();

        for (Packet other : mgr.allPackets) {
            if (other == this) continue;              // skip self
            Point op = other.getPoint();
            if (op == null) continue;                 // queued somewhere

            if (point.distance(op) < SAFE_GAP) {      // inside protection zone
                avgX += op.x;  avgY += op.y;  hits++;
            }
        }

        /* decide direction: +1 fwd, −1 back, 0 hover */
        dir = +1;                                     // default  forward
        if (hits > 0) {
            avgX /= hits;  avgY /= hits;              // barycentre of intruders

            /* unit tangent of current segment */
            Point a = path.get(segIdx);
            Point b = path.get(segIdx + 1);
            double tx = b.x - a.x, ty = b.y - a.y;
            double len = Math.hypot(tx, ty);
            if (len > 0) { tx /= len; ty /= len; }

            /* vector from us to barycentre */
            double vx = avgX - point.x;
            double vy = avgY - point.y;

            double dot = tx*vx + ty*vy;
            if (Math.abs(dot) < 1e-6) dir = 0;         // side-by-side  → hover
            else dir = (dot > 0) ? -1 : +1;            // ahead → retreat, behind → advance
        }


        /* ── 3 ▸ integrate arc-length ----------------------------------- */
        float remaining = dir * BASE_SPEED * dt;

        while (remaining != 0f && segIdx >= 0 && segIdx < segLen.size()) {

            if (remaining > 0f) {                      // → forward
                float segRemain = segLen.get(segIdx) - sInSeg;
                if (remaining < segRemain) {
                    sInSeg += remaining;
                    remaining = 0f;
                } else {
                    remaining -= segRemain;
                    segIdx++;  sInSeg = 0f;
                }
            } else {                                   // ← backward
                float stepBack = Math.min(-remaining, sInSeg);
                sInSeg -= stepBack;
                remaining += stepBack;
                if (sInSeg == 0f && segIdx > 0) {
                    segIdx--;
                    sInSeg = segLen.get(segIdx);
                }
            }
            updatePoint();
        }

        /* ── 4 ▸ arrival at either end (clean-up done by System) ───────── */
        if (segIdx >= segLen.size()) {                  // destination end
            line.getEnd().getParentSystem().receivePacket(this);
            isMoving = false; setLine(null);            // detach once
        }
        else if (segIdx < 0) {                          // origin end
            line.getStart().getParentSystem().receivePacket(this);
            isMoving = false; setLine(null);
        }
    }


    /* ---------- helpers ---------- */
    private void initPathTables() {
        path   = line.getPath(6);                 // same smoothness everywhere
        segLen = new ArrayList<>(path.size() - 1);
        for (int i = 0; i < path.size() - 1; i++)
            segLen.add((float) path.get(i).distance(path.get(i + 1)));

        segIdx = 0; sInSeg = 0f;
        point  = path.get(0);
        isMoving = true;
    }

    private void updatePoint() {
        if (segIdx < 0 || segIdx >= segLen.size()) return;
        point = lerp(path.get(segIdx), path.get(segIdx + 1),
                sInSeg / segLen.get(segIdx));
    }

    @Override protected void resetPath() {
        path   = null;
        segLen = null;
        segIdx = 0;
        sInSeg = 0f;
    }
}
